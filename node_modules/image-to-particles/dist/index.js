"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ImgToParticles: () => ImgToParticles
});
module.exports = __toCommonJS(src_exports);

// src/ImgToParticles.tsx
var import_react = __toESM(require("react"));

// src/utils.ts
var import_clsx = require("clsx");
var import_tailwind_merge = require("tailwind-merge");
function cn(...inputs) {
  return (0, import_tailwind_merge.twMerge)((0, import_clsx.clsx)(inputs));
}

// src/ImgToParticles.tsx
function ImgToParticles({
  img_64,
  pixelGap = 4,
  classNames,
  imgPositionX = "middle",
  imgPositionY = "middle",
  pixelSize = 4,
  pixelFriction = 0.98,
  pixelEase = 0.8,
  mouseCircleRadius = 1e3
}) {
  const canvasRef = (0, import_react.useRef)(null);
  const imgRef = (0, import_react.useRef)(null);
  const animationRef = (0, import_react.useRef)(null);
  const calculatePositionValue = (position) => {
    switch (position) {
      case "left":
        return 0;
      case "middle":
        return 0.5;
      case "right":
        return 1;
      default:
        return 0.5;
    }
  };
  const posX = calculatePositionValue(imgPositionX);
  const posY = calculatePositionValue(imgPositionY);
  (0, import_react.useEffect)(() => {
    if (!canvasRef?.current || !imgRef?.current)
      return;
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext("2d", { willReadFrequently: true });
    const particles = [];
    canvas.width = canvas.getBoundingClientRect().width;
    canvas.height = canvas.getBoundingClientRect().height;
    const image1 = imgRef.current;
    const addParticle = (particle) => {
      particle.update = () => {
        particle.dx = particle.mouse.x - particle.x;
        particle.dy = particle.mouse.y - particle.y;
        particle.distance = particle.dx * particle.dx + particle.dy * particle.dy;
        particle.force = -particle.mouse.radius / particle.distance;
        if (particle.distance < particle.mouse.radius) {
          particle.angle = Math.atan2(particle.dy, particle.dx);
          particle.vx += particle.force * Math.cos(particle.angle);
          particle.vy += particle.force * Math.sin(particle.angle);
        }
        particle.x += (particle.vx *= particle.friction) + (particle.originX - particle.x) * particle.ease;
        particle.y += (particle.vy *= particle.friction) + (particle.originY - particle.y) * particle.ease;
      };
      particles.push(particle);
    };
    function drawParticle(x, y, size, color) {
      if (!ctx)
        return;
      ctx.fillStyle = color;
      ctx.fillRect(x, y, size, size);
    }
    function drawImage(img) {
      ctx?.drawImage(img, canvas.width * posX - img.width * posX, canvas.height * posY - img.height * posY);
    }
    function initEffect() {
      drawImage(image1);
      const pixels = ctx?.getImageData(0, 0, canvas.width, canvas.height).data;
      if (pixels) {
        for (let y = 0; y < canvas?.height; y += pixelGap) {
          for (let x = 0; x < canvas?.width; x += pixelGap) {
            const index = (y * canvas?.width + x) * 4;
            const red = pixels[index];
            const green = pixels[index + 1];
            const blue = pixels[index + 2];
            const alpha = pixels[index + 3];
            const color = `rgb(${red}, ${green}, ${blue})`;
            if (alpha > 0) {
              addParticle({
                x: Math.random() * canvas?.width,
                y,
                originX: Math.floor(x),
                originY: Math.floor(y),
                color,
                size: pixelSize,
                vx: 0,
                vy: 0,
                dx: 0,
                dy: 0,
                distance: 0,
                force: 0,
                angle: 0,
                friction: pixelFriction,
                ease: pixelEase,
                mouse: {
                  radius: mouseCircleRadius,
                  x: 0,
                  y: 0
                },
                mousePosition: () => {
                },
                update: () => {
                }
              });
            }
          }
        }
      }
    }
    function drawEffect() {
      particles.forEach((particle) => drawParticle(particle.x, particle.y, particle.size, particle.color));
    }
    function updateEffect(particles2) {
      particles2.forEach((particle) => particle.update());
    }
    initEffect();
    function animate() {
      ctx?.clearRect(0, 0, canvas.width, canvas.height);
      drawEffect();
      updateEffect(particles);
      animationRef.current = requestAnimationFrame(animate);
    }
    animate();
    const handleMouseMove = (event) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      particles.forEach((particle) => {
        particle.mouse.x = mouseX;
        particle.mouse.y = mouseY;
      });
    };
    canvas.addEventListener("mousemove", handleMouseMove);
    return () => {
      canvas.removeEventListener("mousemove", handleMouseMove);
      cancelAnimationFrame(animationRef.current);
    };
  }, []);
  return /* @__PURE__ */ import_react.default.createElement(
    "canvas",
    {
      ref: canvasRef,
      className: cn("absolute z-50 canvas-particle h-full w-full   object-contain", classNames?.canvasClassName)
    },
    /* @__PURE__ */ import_react.default.createElement("img", { ref: imgRef, src: img_64, className: cn("img-particle", classNames?.imgClassName) })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ImgToParticles
});
